#!/usr/bin/env bash

set -euo pipefail

PROG_NAME="comicpress"
CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"
CACHE_DIR=$(mktemp -d "$CACHE_HOME/$PROG_NAME/XXXXXX")

TMPDIR="$CACHE_HOME/parallel"
MAGICK_TEMPORARY_PATH="$CACHE_HOME/magick"

IMAGE_QUALITY=100

main() {
    parse_params "$@"

    if ! ls "$INPUT_DIRECTORY"/*.pdf > /dev/null 2>&1; then
        echo "$PROG_NAME: '$INPUT_DIRECTORY' is not a directory containing PDF files." >&2
        exit 1
    fi

    mkdir -p "$OUTPUT_DIRECTORY" "$CACHE_DIR" "$MAGICK_TEMPORARY_PATH"

    if command -v parallel > /dev/null; then
        mkdir -p "$TMPDIR"
        export CACHE_DIR PIXEL_DENSITY MAGICK_MEMORY_LIMIT DISPLAY_WIDTH \
            DISPLAY_HEIGHT SCALING_FILTER IMAGE_QUALITY OUTPUT_DIRECTORY \
            TMPDIR MAGICK_TEMPORARY_PATH
        export -f process_pdf list_to_ranges
        echo "Processing PDFs in parallel..."
        ls "$INPUT_DIRECTORY"/*.pdf | parallel -j "$NUM_THREADS" process_pdf
    else
        printf "$PROG_NAME: %s %s %s\n" \
            'Warning: `parallel` command not found. The script will run' \
            "sequentially, which is slower. Itâ€™s recommended to stop the" \
            "script and install GNU Parallel." \
            >&2
        for pdf in "$1"/*.pdf; do
            process_pdf "$pdf"
        done
    fi

    rm -rf "$CACHE_DIR/"
    echo "All tasks complete."
}

parse_params() {
    set_param() {
        local param_name="$1"
        local var_name="$2"
        local value="$3"
        if [[ -z "$value" ]]; then
            echo "$PROG_NAME: Parameter '$param_name' needs an argument." >&2
            exit 1
        fi
        eval "$var_name='$value'"
    }

    check_device() {
        if [[ "$DEVICE" = "Kobo Sage" ]] then
            PIXEL_DENSITY=300
            DISPLAY_WIDTH=1440
            DISPLAY_HEIGHT=1920
        else
            printf "$PROG_NAME: %s %s\n" \
                "'$DEVICE' is not a recognized device. See \`-list_devices\`" \
                "for a list of recognized devices." \
                >&2
            exit 1;
        fi
    }

    check_filter() {
        if ! magick -list filter | grep -q "^$SCALING_FILTER$"; then
            printf "$PROG_NAME: %s %s %s\n" \
                "'$SCALING_FILTER' is not a valid scaling filter. Try" \
                '`magick -list filter` to see a full list of possible' \
                "filters." \
                >&2
            exit 1
        fi
    }

    SCALING_FILTER=MagicKernelSharp2021
    MAGICK_MEMORY_LIMIT=2GiB
    NUM_THREADS=4

    while [[ "$#" -gt 0 ]]; do
        if [[ "${1:0:1}" != - ]]; then
            if [[ -z "$2" || "${2:0:1}" = "-" ]]; then
                printf "$PROG_NAME: %s %s\n" \
                    "Input directory parameter must have an output directory" \
                    "parameter after it." \
                    >&2
                exit 1
            fi
            INPUT_DIRECTORY="$1"
            OUTPUT_DIRECTORY="$2"
            shift 2;
            continue;
        fi

        case "$1" in
            -help)
                help
                exit
                ;;
            -device)
                set_param "$1" DEVICE "$2"
                check_device
                shift
                ;;
            -density | -d)
                set_param "$1" PIXEL_DENSITY "$2"
                shift
                ;;
            -width | -w)
                set_param "$1" DISPLAY_WIDTH "$2"
                shift
                ;;
            -height | -h)
                set_param "$1" DISPLAY_HEIGHT "$2"
                shift
                ;;
            -filter | -f)
                set_param "$1" SCALING_FILTER "$2"
                check_filter
                shift
                ;;
            -jobs | -j)
                set_param "$1" NUM_THREADS "$2"
                shift
                ;;
            -magick_memory_limit)
                set_param "$1" MAGICK_MEMORY_LIMIT "$2"
                shift
                ;;
            *)
                echo "$PROG_NAME: '$1' is not a valid parameter." >&2
                exit 1
                ;;
        esac

        shift
    done

    if [[
        -z "$PIXEL_DENSITY" \
        || -z "$DISPLAY_WIDTH" \
        || -z "$DISPLAY_HEIGHT" \
        || -z "$INPUT_DIRECTORY" \
    ]]
    then
        help
        exit 1
    fi
}

help() {
    echo 'comicpress: command-line tool to convert and compress comics and manga

Usage:
    Option 1: comicpress -device DEVICE_NAME INPUT_DIRECTORY OUTPUT_DIRECTORY
    Option 2: comicpress -density PIXEL_DENSITY -width DISPLAY_WIDTH -height DISPLAY_HEIGHT INPUT_DIRECTORY OUTPUT_DIRECTORY

Parameters:
    -device             Ereader device to target. This automatically sets the correct values for `-density`, `-width`, and `-height`. For a full list, see `-list_devices`.
    -density, -d        Pixel density of the display to target in pixels per inch
    -width, -w          Width of the display to target in pixels
    -height, -h         Height of the display to target in pixels
    -filter, f          ImageMagick scaling filter to use (default: MagickKernelSharp2021). Run `magick -list filter` for a full list of possible choices.
    -list_devices, -l   List of all devices and their respective values for pixel density, width, and height.
    -help               Print this help message and exit.

Examples:
    1. comicpress -device "Kobo Sage" PDF CBZ
    2. comicpress -density 300 -width 1440 -height 1920 PDF CBZ
'
}

list_devices() {
    echo "Kobo Sage (density: 300, width: 1440, height: 1920)"
}

list_to_ranges() {
    [ -z "$1" ] && return

    local -a nums=($1)
    local ranges=()
    local start=${nums[0]}
    local end=${nums[0]}

    for ((i = 1; i < ${#nums[@]}; i++)); do
        if [[ ${nums[i]} -eq $((end + 1)) ]]; then
            end=${nums[i]}
        else
            [ "$start" -eq "$end" ] && ranges+=("$start") || ranges+=("$start-$end")
            start=${nums[i]}
            end=${nums[i]}
        fi
    done
    [ "$start" -eq "$end" ] && ranges+=("$start") || ranges+=("$start-$end")

    (IFS=,; echo "${ranges[*]}")
}

process_pdf() {
    local pdf_file_name="$1"
    local pdf_base_name
    pdf_base_name="$(basename "$pdf_file_name" .pdf)"

    echo "Processing '$pdf_file_name'..."

    local temp_dir="$CACHE_DIR/$pdf_base_name"
    mkdir -p "$temp_dir"

    local num_pages
    num_pages="$(pdfinfo "$pdf_file_name" | grep "^Pages:" | awk '{print $2}')"
    local num_pages_digits
    num_pages_digits="$(echo -n "$num_pages" | wc -c | tr -d "[:space:]")"

    echo "Analyzing $num_pages pages..."

    local pages_non_monochrome
    mapfile -t pages_non_monochrome < <(
        pdfimages -list "$pdf_file_name" |
        tail -n +3 |
        awk '$3 != "stencil" {print $1}' |
        sort -un
    )

    local all_pages
    mapfile -t all_pages < <(seq 1 "$num_pages")
    local pages_monochrome
    mapfile -t pages_monochrome < <(comm -23 <(printf "%s\n" "${all_pages[@]}") <(printf "%s\n" "${pages_non_monochrome[@]}"))

    if [ ${#pages_monochrome[@]} -gt 0 ]; then
        local -a indices=()
        for p in "${pages_monochrome[@]}"; do indices+=($((p - 1))); done

        local index_range_str
        index_range_str=$(list_to_ranges "${indices[*]}")

        local magick_cmd=(magick)
        [[ "$MAGICK_MEMORY_LIMIT" != "off" ]] && magick_cmd+=(-limit memory "$MAGICK_MEMORY_LIMIT")

        magick_cmd+=(
            -density "$PIXEL_DENSITY"
            "${pdf_file_name}[${index_range_str}]"
            -trim +repage
            -colorspace Gray
            -filter "$SCALING_FILTER"
            -resize "${DISPLAY_WIDTH}x$DISPLAY_HEIGHT"
            -quality "$IMAGE_QUALITY"
            -define webp:method=6
            -strip
            -colors 8
            -level '0%,100%,0.5'
            "$temp_dir/%0${num_pages_digits}d.webp"
        )
        "${magick_cmd[@]}" 2> /dev/null || true
    fi

    if [ ${#pages_non_monochrome[@]} -gt 0 ]; then
        local -a indices=()
        for p in "${pages_non_monochrome[@]}"; do indices+=($((p - 1))); done

        local index_range_str
        index_range_str=$(list_to_ranges "${indices[*]}")

        local magick_cmd=(magick)
        [[ -z "${MAGICK_UNLIMITED_MEMORY:-}" ]] && magick_cmd+=(-limit memory "$MAGICK_MEMORY_LIMIT")

        magick_cmd+=(
            -density "$PIXEL_DENSITY"
            "${pdf_file_name}[${index_range_str}]"
            -trim +repage
            -colorspace Gray
            -filter "$SCALING_FILTER"
            -resize "${DISPLAY_WIDTH}x$DISPLAY_HEIGHT"
            -quality "$IMAGE_QUALITY"
            -define webp:method=6
            -strip
            -colors 128
            -level '0%,100%,0.5'
            "$temp_dir/%0${num_pages_digits}d.webp"
        )
        "${magick_cmd[@]}" 2> /dev/null || true
    fi

    local files_to_rename
    mapfile -t files_to_rename < <(find "$temp_dir" -maxdepth 1 -name "*.webp" | sort -r)

    for old_file in "${files_to_rename[@]}"; do
        local base
        base=$(basename "$old_file" .webp)

        local num=$((10#$base))
        local new_num=$((num + 1))

        local new_filename
        new_filename=$(printf "%0*d.webp" "$num_pages_digits" "$new_num")

        mv "$old_file" "$temp_dir/$new_filename"
    done

    echo "Creating archive '$OUTPUT_DIRECTORY/$pdf_base_name.cbz'..."
    zip -0 -j "$OUTPUT_DIRECTORY/${pdf_base_name}.cbz" "$temp_dir"/*.webp
    printf "%s\n\n" "Archive '$OUTPUT_DIRECTORY/$pdf_base_name.cbz' created."
}

main "$@"
