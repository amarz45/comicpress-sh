#!/usr/bin/env bash

set -euo pipefail

die() {
    printf "%s: %s\n" "${CONFIG[prog_name]}" "$*" >&2
    exit 1
}

declare -A CONFIG=(
    [prog_name]="comicpress"
    [cache_home]="${XDG_CACHE_HOME:-$HOME/.cache}"
    [image_quality]=100
    [scaling_filter]="MagicKernelSharp2021"
    [magick_memory_limit]="unset"
    [num_threads]="$(nproc)"
    [output_directory]="."
    [device]=""
    [pixel_density]="300"
    [display_width]="unset"
    [display_height]="unset"
)

declare -A DEVICES=(
    # Kindle
    ["Kindle (11th Gen, 2022)"]="300 1072 1448"
    ["Kindle Paperwhite (11th Gen)"]="300 1236 1648"
    ["Kindle Paperwhite Signature Edition"]="300 1236 1648"
    ["Kindle Oasis (3rd Gen)"]="300 1264 1680"
    ["Kindle Scribe"]="300 1860 2480"

    # Kobo
    ["Kobo Clara BW"]="300 1072 1448"
    ["Kobo Clara Colour"]="300 1072 1448"
    ["Kobo Libra Colour"]="300 1264 1680"
    ["Kobo Sage"]="300 1440 1920"
    ["Kobo Elipsa 2E"]="227 1404 1872"

    # PocketBook
    ["PocketBook Verse"]="212 758 1024"
    ["PocketBook Verse Pro"]="300 1072 1448"
    ["PocketBook InkPad 4"]="300 1404 1872"
    ["PocketBook InkPad Color 3"]="300 1404 1872"
    ["PocketBook Era"]="300 1264 1680"

    # Boox
    ["Boox Palma"]="300 824 1648"
    ["Boox Page"]="300 1264 1680"
    ["Boox Note Air3 C"]="300 1404 1872"
    ["Boox Tab Ultra C Pro"]="300 1860 2480"
    ["Boox Tab X"]="207 1600 2560"

    # reMarkable
    ["reMarkable 2"]="226 1872 1404"
)

CACHE_DIR=$(mktemp -d "${CONFIG[cache_home]}/${CONFIG[prog_name]}/XXXXXX")
trap 'rm -rf "$CACHE_DIR"' EXIT

TMPDIR="${CONFIG[cache_home]}/parallel"
MAGICK_TEMPORARY_PATH="${CONFIG[cache_home]}/magick"

main() {
    parse_params "$@"
    mkdir -p "${CONFIG[output_directory]}" "$CACHE_DIR" "$MAGICK_TEMPORARY_PATH"

    if command -v parallel > /dev/null; then
        mkdir -p "$TMPDIR"

        export CONFIG_STR="$(declare -p CONFIG)"
        export CACHE_DIR TMPDIR MAGICK_TEMPORARY_PATH
        export -f \
            process_file process_pdf process_archive list_to_ranges die \
            create_cbz_archive get_magick_common_params run_magick_convert \
            run_magick_mogrify

        printf "%s\n" "${INPUT_FILES[@]}" \
            | parallel -j "${CONFIG[num_threads]}" process_file
    else
        echo \
            "${CONFIG[prog_name]}" \
            "Warning: 'parallel' command not found. The script will run" \
            "sequentially." \
            >&2
        for file in "${INPUT_FILES[@]}"; do
            process_file "$file"
        done
    fi

    echo "All tasks complete."
}

parse_params() {
    INPUT_FILES=()
    set_param() {
        local param_name="$1"
        local config_key="$2"
        local value="$3"
        if [[ -z "$value" ]]; then
            die "Parameter '$param_name' needs an argument."
        fi
        CONFIG[$config_key]="$value"
    }

    check_device() {
        local device_name="${CONFIG[device]}"
        if [[ -n "${DEVICES[$device_name]:-}" ]]; then
            local -a specs=(${DEVICES[$device_name]})
            CONFIG[pixel_density]="${specs[0]}"
            CONFIG[display_width]="${specs[1]}"
            CONFIG[display_height]="${specs[2]}"
        else
            die "'$device_name' is not a recognized device. See '-list_devices' for a list of recognized devices."
        fi
    }

    check_filter() {
        if ! magick -list filter | grep -q "^${CONFIG[scaling_filter]}$"; then
            die "'${CONFIG[scaling_filter]}' is not a valid scaling filter. Try 'magick -list filter' to see a full list of possible filters."
        fi
    }

    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            -help)
                help
                exit
                ;;
            -list_devices)
                list_devices
                exit
                ;;
            -directory | -d)
                set_param "$1" output_directory "$2"
                shift
                ;;
            -device)
                set_param "$1" device "$2"
                check_device
                shift
                ;;
            -density)
                set_param "$1" pixel_density "$2"
                shift
                ;;
            -width | -w)
                set_param "$1" display_width "$2"
                shift
                ;;
            -height | -h)
                set_param "$1" display_height "$2"
                shift
                ;;
            -filter | -f)
                set_param "$1" scaling_filter "$2"
                check_filter
                shift
                ;;
            -jobs | -j)
                set_param "$1" num_threads "$2"
                shift
                ;;
            -magick_memory_limit)
                set_param "$1" magick_memory_limit "$2"
                shift
                ;;
            -*)
                die "'$1' is not a valid parameter."
                ;;
            *)
                INPUT_FILES+=("$1")
                ;;
        esac
        shift
    done

    if ((${#INPUT_FILES[@]} == 0)); then
        help
        die "No input files specified."
    fi
}

help() {
    echo 'comicpress: command-line tool to convert and compress comics and manga

Usage:
    comicpress [OPTIONS]... FILE...

Example:
    comicpress -device "Kobo Sage" -d output_directory directory_with_pdf_files/*.pdf

Parameters:
    -directory, -d DIRECTORY    Output directory (default: current directory).
    -device DEVICE              Ereader device to target (sets density, width, height).
    -density DENSITY            Pixel density of the display in pixels per inch (default: 300, unless the `-device` option is used).
    -width, -w WIDTH            Width of the display in pixels (default: unset, unless the `-device` option is used).
    -height, -h HEIGHT          Height of the display in pixels (default: unset, unless the `-device` option is used).
    -filter, -f FILTER          ImageMagick scaling filter (default: MagicKernelSharp2021).
    -jobs, -j NUM               Number of parallel jobs to run (default: the number of threads on the system).
    -magick_memory_limit LIMIT  Limits the amount of memory each ImageMagick instance is allowed to use (e.g., 1GiB) (default: unset).
    -list_devices               List all supported devices.
    -help                       Print this help message and exit.
'
}

list_devices() {
    for device in "${!DEVICES[@]}"; do
        local -a specs=(${DEVICES[$device]})
        echo \
            "$device" \
            "(density: ${specs[0]}, width: ${specs[1]}, height: ${specs[2]})"
    done
}

list_to_ranges() {
    if [[ -z "$1" ]]; then
        return
    fi

    local -a nums=($1)
    local ranges=()
    local start=${nums[0]}
    local end=${nums[0]}

    for ((i = 1; i < ${#nums[@]}; i += 1)); do
        if [[ ${nums[i]} -eq $((end + 1)) ]]; then
            end=${nums[i]}
        else
            if [[ "$start" -eq "$end" ]]; then
                ranges+=("$start")
            else
                ranges+=("$start-$end")
            fi
            start=${nums[i]}
            end=${nums[i]}
        fi
    done
    if [[ "$start" -eq "$end" ]]; then
        ranges+=("$start")
    else
        ranges+=("$start-$end")
    fi

    (IFS=,; echo "${ranges[*]}")
}

create_cbz_archive() {
    local output_file_basename="$1"
    local image_source_dir="$2"
    local output_cbz_path="${CONFIG[output_directory]}/${output_file_basename}.cbz"

    echo "Creating archive '$output_cbz_path'..."
    zip \
        -0 -j \
        "$output_cbz_path" \
        "$image_source_dir"/*.webp \
        > /dev/null
    printf "Archive '$output_cbz_path' created.\n\n"
}

get_magick_common_params() {
    if [[ "${CONFIG[magick_memory_limit]}" != unset ]]; then
        printf "%s\n" -limit memory "${CONFIG[magick_memory_limit]}"
    fi
    printf "%s\n" \
        -trim +repage \
        -colorspace Gray \
        -filter "${CONFIG[scaling_filter]}"
    if [[ "${CONFIG[display_width]}" != unset && "${CONFIG[display_height]}" != unset ]]; then
        printf "%s\n" \
            -resize "${CONFIG[display_width]}x${CONFIG[display_height]}"
    fi
    printf "%s\n" \
        -quality "${CONFIG[image_quality]}" \
        -define webp:method=6 \
        -strip \
        -level 0%,100%,0.5
}

run_magick_convert() {
    local input_file_with_ranges="$1"
    local output_pattern="$2"
    local colors="$3"

    local -a common_params
    mapfile -t common_params < <(get_magick_common_params)

    magick \
        -density "${CONFIG[pixel_density]}" \
        "$input_file_with_ranges" \
        "${common_params[@]}" \
        -colors "$colors" \
        "$output_pattern" \
        2> /dev/null || true
}

run_magick_mogrify() {
    local image_dir="$1"
    local colors="$2"

    local -a common_params
    mapfile -t common_params < <(get_magick_common_params)

    magick mogrify \
        "${common_params[@]}" \
        -colors "$colors" \
        -format webp \
        "$image_dir"/* \
        2> /dev/null || true
}

process_file() {
    if [[ -v CONFIG_STR ]]; then
        eval "$CONFIG_STR"
    fi

    local input_file="$1"
    if [[ "$input_file" == *.pdf ]]; then
        process_pdf "$input_file"
    elif [[ "$input_file" == *.cbz || "$input_file" == *.cbr ]]; then
        process_archive "$input_file"
    else
        echo "${CONFIG[prog_name]}: Skipping unsupported file '$input_file'." >&2
    fi
}

process_pdf() {
    local pdf_file_name="$1"
    local pdf_base_name
    pdf_base_name="$(basename "$pdf_file_name" .pdf)"

    echo "Processing PDF '$pdf_file_name'..."

    local temp_dir="$CACHE_DIR/$pdf_base_name"
    mkdir -p "$temp_dir"

    local num_pages="$(
        pdfinfo "$pdf_file_name" | grep "^Pages:" | awk '{print $2}'
    )"
    if [[ -z "$num_pages" ]]; then
        die "Could not determine number of pages for '$pdf_file_name'."
    fi

    local num_pages_digits="$(echo -n "$num_pages" | wc -c | tr -d "[:space:]")"

    echo "Analyzing $num_pages pages..."

    local pages_non_monochrome
    mapfile -t pages_non_monochrome < <(
        pdfimages -list "$pdf_file_name" |
        tail -n +3 |
        awk '$3 != "stencil" {print $1}' |
        sort -un
    )

    local all_pages
    mapfile -t all_pages < <(seq 1 "$num_pages")
    local pages_monochrome
    mapfile -t pages_monochrome < \
        <(comm -23 <(printf "%s\n" "${all_pages[@]}") \
        <(printf "%s\n" "${pages_non_monochrome[@]}"))

    if [ ${#pages_monochrome[@]} -gt 0 ]; then
        local -a indices=()
        for p in "${pages_monochrome[@]}"; do
            indices+=($((p - 1)))
        done
        local index_range_str
        index_range_str=$(list_to_ranges "${indices[*]}")
        run_magick_convert \
            "${pdf_file_name}[${index_range_str}]" \
            "$temp_dir/%0${num_pages_digits}d.webp" \
            8
    fi

    if [ ${#pages_non_monochrome[@]} -gt 0 ]; then
        local -a indices=()
        for p in "${pages_non_monochrome[@]}"; do
            indices+=($((p - 1)))
        done
        local index_range_str
        index_range_str=$(list_to_ranges "${indices[*]}")
        run_magick_convert \
            "${pdf_file_name}[${index_range_str}]" \
            "$temp_dir/%0${num_pages_digits}d.webp" \
            128
    fi

    local files_to_rename
    mapfile -t files_to_rename < \
        <(find "$temp_dir" -maxdepth 1 -name "*.webp" | sort -r)
    for old_file in "${files_to_rename[@]}"; do
        local base
        base=$(basename "$old_file" .webp)
        local num=$((10#$base))
        local new_num=$((num + 1))
        local new_filename
        new_filename=$(printf "%0*d.webp" "$num_pages_digits" "$new_num")
        mv "$old_file" "$temp_dir/$new_filename"
    done

    create_cbz_archive "$pdf_base_name" "$temp_dir"
}

process_archive() {
    local archive_file_name="$1"
    local base_name
    local extension
    local temp_dir
    local -a extract_cmd

    if [[ "$archive_file_name" == *.cbz ]]; then
        extension=".cbz"
    elif [[ "$archive_file_name" == *.cbr ]]; then
        extension=".cbr"
    else
        die "Unsupported archive type passed to process_archive: '$archive_file_name'"
    fi

    base_name="$(basename "$archive_file_name" "$extension")"
    temp_dir="$CACHE_DIR/$base_name"
    local images_renamed_dir="$temp_dir/renamed"

    echo "Processing Archive '$archive_file_name'..."

    mkdir -p "$temp_dir" "$images_renamed_dir"

    if [[ "$extension" == ".cbz" ]]; then
        extract_cmd=(unzip -jd "$temp_dir" "$archive_file_name")
    elif [[ "$extension" == ".cbr" ]]; then
        if ! command -v unrar >/dev/null; then
            die "unrar command not found, but is required to process CBR files."
        fi
        extract_cmd=(unrar e "$archive_file_name" "$temp_dir/")
    fi

    "${extract_cmd[@]}"

    local num_files="$(find "$temp_dir" -maxdepth 1 -type f | wc -l)"
    local num_files_digits="$(echo -n "$num_files" | wc -c)"
    local counter=1

    while IFS= read -r image_file_name; do
        local new_base_name="$(printf "%0*d" "$num_files_digits" "$counter")"
        local file_extension="${image_file_name##*.}"
        local new_file_name="$new_base_name.$file_extension"
        mv "$image_file_name" "$images_renamed_dir/$new_file_name"
        ((counter += 1))
    done < <(find "$temp_dir" -maxdepth 1 -type f | sort)

    run_magick_mogrify "$images_renamed_dir" 128

    create_cbz_archive "$base_name" "$images_renamed_dir"
}

main "$@"
