#!/usr/bin/env bash

set -euo pipefail

PROG_NAME="comicpress"
CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"
CACHE_DIR=$(mktemp -d "$CACHE_HOME/$PROG_NAME/XXXXXX")
trap 'rm -rf "$CACHE_DIR"' EXIT

TMPDIR="$CACHE_HOME/parallel"
MAGICK_TEMPORARY_PATH="$CACHE_HOME/magick"

IMAGE_QUALITY=100

main() {
    parse_params "$@"
    mkdir -p "$OUTPUT_DIRECTORY" "$CACHE_DIR" "$MAGICK_TEMPORARY_PATH"

    if command -v parallel > /dev/null; then
        mkdir -p "$TMPDIR"

        export CACHE_DIR PIXEL_DENSITY MAGICK_MEMORY_LIMIT DISPLAY_WIDTH \
            DISPLAY_HEIGHT SCALING_FILTER IMAGE_QUALITY OUTPUT_DIRECTORY \
            TMPDIR MAGICK_TEMPORARY_PATH
        export -f process_file process_pdf process_cbz list_to_ranges

        printf "%s\n" "${INPUT_FILES[@]}" | parallel -j "$NUM_THREADS" process_file
    else
        printf "$PROG_NAME: %s %s\n" \
            "Warning: 'parallel' command not found. The script will run" \
            "sequentially." \
            >&2
        for file in "${INPUT_FILES[@]}"; do
            process_file "$file"
        done
    fi

    echo "All tasks complete."
}

parse_params() {
    INPUT_FILES=()
    set_param() {
        local param_name="$1"
        local var_name="$2"
        local value="$3"
        if [[ -z "$value" ]]; then
            echo "$PROG_NAME: Parameter '$param_name' needs an argument." >&2
            exit 1
        fi
        eval "$var_name='$value'"
    }

    check_device() {
        if [[ "$DEVICE" = "Kobo Sage" ]]; then
            PIXEL_DENSITY=300
            DISPLAY_WIDTH=1440
            DISPLAY_HEIGHT=1920
        else
            printf "$PROG_NAME: %s %s\n" \
                "'$DEVICE' is not a recognized device. See '-list_devices'" \
                "for a list of recognized devices." \
                >&2
            exit 1;
        fi
    }

    check_filter() {
        if ! magick -list filter | grep -q "^$SCALING_FILTER$"; then
            printf "$PROG_NAME: %s %s %s\n" \
                "'$SCALING_FILTER' is not a valid scaling filter. Try" \
                "'magick -list filter' to see a full list of possible" \
                "filters." \
                >&2
            exit 1
        fi
    }

    SCALING_FILTER=MagicKernelSharp2021
    MAGICK_MEMORY_LIMIT=1GiB
    NUM_THREADS=4
    OUTPUT_DIRECTORY="."

    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            -help)
                help
                exit
                ;;
            -list_devices)
                list_devices
                exit
                ;;
            -directory | -d)
                set_param "$1" OUTPUT_DIRECTORY "$2"
                shift
                ;;
            -device)
                set_param "$1" DEVICE "$2"
                check_device
                shift
                ;;
            -density)
                set_param "$1" PIXEL_DENSITY "$2"
                shift
                ;;
            -width | -w)
                set_param "$1" DISPLAY_WIDTH "$2"
                shift
                ;;
            -height | -h)
                set_param "$1" DISPLAY_HEIGHT "$2"
                shift
                ;;
            -filter | -f)
                set_param "$1" SCALING_FILTER "$2"
                check_filter
                shift
                ;;
            -jobs | -j)
                set_param "$1" NUM_THREADS "$2"
                shift
                ;;
            -magick_memory_limit)
                set_param "$1" MAGICK_MEMORY_LIMIT "$2"
                shift
                ;;
            -*)
                echo "$PROG_NAME: '$1' is not a valid parameter." >&2
                exit 1
                ;;
            *)
                INPUT_FILES+=("$1")
                ;;
        esac
        shift
    done

    if (( ${#INPUT_FILES[@]} == 0 )); then
        echo "$PROG_NAME: No input files specified." >&2
        help
        exit 1
    fi

    if [[
        -z "${PIXEL_DENSITY:-}" \
        || -z "${DISPLAY_WIDTH:-}" \
        || -z "${DISPLAY_HEIGHT:-}" \
    ]]
    then
        printf "$PROG_NAME: %s %s\n" \
            "Target device parameters are not set. Use '-device' or manual" \
            "settings." \
            >&2
        help
        exit 1
    fi
}

help() {
    echo 'comicpress: command-line tool to convert and compress comics and manga

Usage:
    comicpress [OPTIONS]... FILE...

Example:
    comicpress -device "Kobo Sage" -d output_directory directory_with_pdf_files/*.pdf

Parameters:
    -directory, -d DIRECTORY  Output directory (default: current directory).
    -device DEVICE            Ereader device to target (sets density, width, height).
    -density DENSITY          Pixel density of the display in pixels per inch.
    -width, -w WIDTH          Width of the display in pixels.
    -height, -h HEIGHT        Height of the display in pixels.
    -filter, -f FILTER        ImageMagick scaling filter (default: MagicKernelSharp2021).
    -jobs, -j NUM             Number of parallel jobs to run (default: 4).
    -help                     Print this help message and exit.
    -list_devices             List all supported devices.
'
}

list_devices() {
    echo "Kobo Sage (density: 300, width: 1440, height: 1920)"
}

list_to_ranges() {
    if [[ -z "$1" ]]; then
        return
    fi

    local -a nums=($1)
    local ranges=()
    local start=${nums[0]}
    local end=${nums[0]}

    for ((i = 1; i < ${#nums[@]}; i++)); do
        if [[ ${nums[i]} -eq $((end + 1)) ]]; then
            end=${nums[i]}
        else
            if [[ "$start" -eq "$end" ]]; then
                ranges+=("$start")
            else
                ranges+=("$start-$end")
            fi
            start=${nums[i]}
            end=${nums[i]}
        fi
    done
    if [[ "$start" -eq "$end" ]]; then
        ranges+=("$start")
    else
        ranges+=("$start-$end")
    fi

    (IFS=,; echo "${ranges[*]}")
}

process_file() {
    local input_file="$1"
    if [[ "$input_file" == *.pdf ]]; then
        process_pdf "$input_file"
    elif [[ "$input_file" == *.cbz ]]; then
        process_cbz "$input_file"
    else
        echo "$PROG_NAME: Skipping unsupported file '$input_file'." >&2
    fi
}

process_pdf() {
    local pdf_file_name="$1"
    local pdf_base_name
    pdf_base_name="$(basename "$pdf_file_name" .pdf)"

    echo "Processing PDF '$pdf_file_name'..."

    local temp_dir="$CACHE_DIR/$pdf_base_name"
    mkdir -p "$temp_dir"

    local num_pages
    num_pages="$(pdfinfo "$pdf_file_name" | grep "^Pages:" | awk '{print $2}')"
    local num_pages_digits
    num_pages_digits="$(echo -n "$num_pages" | wc -c | tr -d "[:space:]")"

    echo "Analyzing $num_pages pages..."

    local pages_non_monochrome
    mapfile -t pages_non_monochrome < <(
        pdfimages -list "$pdf_file_name" |
        tail -n +3 |
        awk '$3 != "stencil" {print $1}' |
        sort -un
    )

    local all_pages
    mapfile -t all_pages < <(seq 1 "$num_pages")
    local pages_monochrome
    mapfile -t pages_monochrome < \
        <(comm -23 <(printf "%s\n" "${all_pages[@]}") \
        <(printf "%s\n" "${pages_non_monochrome[@]}"))

    if [ ${#pages_monochrome[@]} -gt 0 ]; then
        local -a indices=()
        for p in "${pages_monochrome[@]}"; do
            indices+=($((p - 1)))
        done
        local index_range_str=$(list_to_ranges "${indices[*]}")
        magick \
            -limit memory "$MAGICK_MEMORY_LIMIT" \
            -density "$PIXEL_DENSITY" \
            "${pdf_file_name}[${index_range_str}]" \
            -trim +repage \
            -colorspace Gray \
            -filter "$SCALING_FILTER" \
            -resize "${DISPLAY_WIDTH}x$DISPLAY_HEIGHT" \
            -quality "$IMAGE_QUALITY" \
            -define webp:method=6 \
            -strip \
            -colors 8 \
            -level 0%,100%,0.5 \
            "$temp_dir/%0${num_pages_digits}d.webp" \
            2> /dev/null || true
    fi

    if [ ${#pages_non_monochrome[@]} -gt 0 ]; then
        local -a indices=()
        for p in "${pages_non_monochrome[@]}"; do
            indices+=($((p - 1)))
        done
        local index_range_str=$(list_to_ranges "${indices[*]}")
        magick \
            -limit memory "$MAGICK_MEMORY_LIMIT" \
            -density "$PIXEL_DENSITY" \
            "${pdf_file_name}[${index_range_str}]" \
            -trim +repage \
            -colorspace Gray \
            -filter "$SCALING_FILTER" \
            -resize "${DISPLAY_WIDTH}x$DISPLAY_HEIGHT" \
            -quality "$IMAGE_QUALITY" \
            -define webp:method=6 \
            -strip \
            -colors 128 \
            -level 0%,100%,0.5 \
            "$temp_dir/%0${num_pages_digits}d.webp" \
            2> /dev/null || true
    fi

    local files_to_rename
    mapfile -t files_to_rename < \
        <(find "$temp_dir" -maxdepth 1 -name "*.webp" | sort -r)
    for old_file in "${files_to_rename[@]}"; do
        local base
        base=$(basename "$old_file" .webp)
        local num=$((10#$base))
        local new_num=$((num + 1))
        local new_filename
        new_filename=$(printf "%0*d.webp" "$num_pages_digits" "$new_num")
        mv "$old_file" "$temp_dir/$new_filename"
    done

    echo "Creating archive '$OUTPUT_DIRECTORY/$pdf_base_name.cbz'..."
    zip \
        -0 -j \
        "$OUTPUT_DIRECTORY/${pdf_base_name}.cbz" \
        "$temp_dir"/*.webp \
        > /dev/null
    printf "Archive '$OUTPUT_DIRECTORY/$pdf_base_name.cbz' created.\n\n"
}

# This is the logic from your second script, formatted to match the first.
process_cbz() {
    local cbz_file_name="$1"
    local base_name
    base_name="$(basename "$cbz_file_name" .cbz)"

    echo "Processing CBZ '$cbz_file_name'..."

    local temp_dir="$CACHE_DIR/$base_name"
    local images_renamed_dir="$temp_dir/renamed"
    mkdir -p "$temp_dir" "$images_renamed_dir"

    unzip -jd "$temp_dir" "$cbz_file_name" > /dev/null

    # Rename files numerically to ensure order
    local num_files="$(find "$temp_dir" -maxdepth 1 -type f | wc -l)"
    local num_files_digits="$(echo -n "$num_files" | wc -c)"
    local counter=1

    while IFS= read -r image_file_name; do
        local new_base_name="$(printf "%0*d" "$num_files_digits" "$counter")"
        local file_extension="${image_file_name##*.}"
        local new_file_name="$new_base_name.$file_extension"
        mv "$image_file_name" "$images_renamed_dir/$new_file_name"
        ((counter += 1))
    done < <(find "$temp_dir" -maxdepth 1 -type f | sort)

    magick mogrify \
        -limit memory "$MAGICK_MEMORY_LIMIT" \
        -trim +repage \
        -colorspace Gray \
        -filter "$SCALING_FILTER" \
        -resize "${DISPLAY_WIDTH}x${DISPLAY_HEIGHT}" \
        -quality "$IMAGE_QUALITY" \
        -define webp:method=6 \
        -strip \
        -colors 128 \
        -level "0%,100%,0.5" \
        -format webp \
        "$images_renamed_dir"/* \
        2> /dev/null || true

    echo "Creating archive '$OUTPUT_DIRECTORY/$base_name.cbz'..."
    zip \
        -0 -j \
        "$OUTPUT_DIRECTORY/$base_name.cbz" \
        "$images_renamed_dir"/*.webp \
        > /dev/null
    printf "Archive '$OUTPUT_DIRECTORY/$base_name.cbz' created.\n\n"
}

main "$@"
